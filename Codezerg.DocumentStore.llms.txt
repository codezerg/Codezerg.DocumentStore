LIBRARY: Codezerg.DocumentStore
LANGUAGE: C#
TARGET_FRAMEWORK: netstandard2.0
DESCRIPTION: Full reference for document-oriented data layer for SQLite — flexible, schema-less, and fully embedded.

================================================
NAMESPACE: Codezerg.DocumentStore
------------------------------------------------
INTERFACE: ISqliteConnectionProvider
  PROPERTY:
    - ProviderName : string
    - DatabaseName : string
    - ConnectionString : string
  METHODS:
    - DbConnection CreateConnection()

CLASS: SqliteConnectionProvider : ISqliteConnectionProvider
  CTORS:
    - SqliteConnectionProvider(IOptions<SqliteDatabaseOptions> options, ILogger<SqliteConnectionProvider>? logger=null)
  PROPERTY (impl):
    - ProviderName : string
    - DatabaseName : string
    - ConnectionString : string
  METHODS (impl):
    - DbConnection CreateConnection()
  DETAILS:
    - Uses DbProviderFactories to create connections for specified provider
    - Supports "Microsoft.Data.Sqlite" (default) and "System.Data.SQLite" providers
    - Applies SQLite pragmas to each connection: journal_mode, page_size, synchronous
    - Connection-per-operation: Creates new connection, opens it, applies pragmas
    - Extracts database name from connection string for display purposes

INTERFACE: IDocument
  PROPERTY:
    - Id : DocumentId
    - CreatedAt : DateTime
    - UpdatedAt : DateTime
  DETAILS:
    - All document types must implement this interface
    - Id is automatically assigned on insert if not set
    - CreatedAt is automatically set when document is first inserted
    - UpdatedAt is automatically updated on every save operation
    - Provides type safety and eliminates reflection overhead

INTERFACE: IDocumentDatabase
  METHODS:
    - Task<IDocumentCollection<T>> GetCollectionAsync<T>(string name) where T : class, IDocument
    - Task CreateCollectionAsync<T>(string name) where T : class, IDocument
    - Task DropCollectionAsync(string name)
    - Task<List<string>> ListCollectionNamesAsync()
  DETAILS:
    - Does NOT implement IDisposable
    - No persistent connections maintained (connection-per-operation pattern)
    - Database instance can be used for the lifetime of the application

INTERFACE: IDocumentCollection<T> where T : class, IDocument
  PROPERTY:
    - CollectionName : string
  METHODS (INSERT):
    - Task InsertOneAsync(T document)
    - Task InsertManyAsync(IEnumerable<T> documents)
  METHODS (FIND):
    - Task<T?> FindByIdAsync(DocumentId id)
    - Task<T?> FindOneAsync(Expression<Func<T, bool>> filter)
    - Task<List<T>> FindAsync(Expression<Func<T, bool>> filter)
    - Task<List<T>> FindAllAsync()
    - Task<List<T>> FindAsync(Expression<Func<T, bool>> filter, int skip, int limit)
  METHODS (COUNT):
    - Task<long> CountAsync(Expression<Func<T, bool>> filter)
    - Task<long> CountAllAsync()
  METHODS (UPDATE):
    - Task<bool> UpdateByIdAsync(DocumentId id, T document)
    - Task<bool> UpdateOneAsync(Expression<Func<T, bool>> filter, T document)
    - Task<long> UpdateManyAsync(Expression<Func<T, bool>> filter, Action<T> updateAction)
  METHODS (DELETE):
    - Task<bool> DeleteByIdAsync(DocumentId id)
    - Task<bool> DeleteOneAsync(Expression<Func<T, bool>> filter)
    - Task<long> DeleteManyAsync(Expression<Func<T, bool>> filter)
  METHODS (QUERY):
    - Task<bool> AnyAsync(Expression<Func<T, bool>> filter)
  METHODS (INDEXING):
    - Task CreateIndexAsync<TField>(Expression<Func<T, TField>> fieldExpression, bool unique=false)
    - Task DropIndexAsync<TField>(Expression<Func<T, TField>> fieldExpression)


CLASS: DocumentId : IEquatable<DocumentId>, IComparable<DocumentId>
  CTORS:
    - DocumentId()
    - DocumentId(byte[] value)
    - DocumentId(string hexString)
  STATIC PROPERTY:
    - Empty : DocumentId
  PROPERTY:
    - Timestamp : DateTime
  STATIC METHODS:
    - DocumentId NewId()
    - DocumentId Parse(string hexString)
    - bool TryParse(string? hexString, out DocumentId id)
  METHODS:
    - override string ToString()
    - byte[] ToByteArray()
    - override bool Equals(object? obj)
    - bool Equals(DocumentId other)
    - override int GetHashCode()
    - int CompareTo(DocumentId other)
  OPERATORS:
    - == (left, right)
    - != (left, right)
    - < (left, right)
    - > (left, right)
    - <= (left, right)
    - >= (left, right)

CLASS: SqliteDocumentDatabase : IDocumentDatabase
  CTORS:
    - SqliteDocumentDatabase(ISqliteConnectionProvider connectionProvider, IOptions<DocumentDatabaseOptions> options, ILogger<SqliteDocumentDatabase>? logger=null)
  PROPERTY:
    - UseJsonB : bool
  METHODS (impl):
    - Task<IDocumentCollection<T>> GetCollectionAsync<T>(string name) where T : class
    - Task CreateCollectionAsync<T>(string name) where T : class
    - Task DropCollectionAsync(string name)
    - Task<List<string>> ListCollectionNamesAsync()
  CONNECTION MANAGEMENT:
    - Uses connection-per-operation pattern
    - Each database operation creates and disposes its own connection
    - No persistent connections maintained
    - SQLite pragmas applied to each new connection
    - Thread-safe schema initialization
    - IMPORTANT: In-memory databases (:memory:) are NOT supported

================================================
NAMESPACE: Codezerg.DocumentStore.Configuration
------------------------------------------------
CLASS: SqliteDatabaseOptions
  PROPERTY:
    - ProviderName : string (default: "Microsoft.Data.Sqlite")
    - ConnectionString : string
    - JournalMode : string? (default: "WAL")
    - PageSize : int? (default: 4096)
    - Synchronous : string? (default: "NORMAL")
  METHODS:
    - void Validate()
  DETAILS:
    - Used by SqliteConnectionProvider to configure connection creation
    - Supports both "Microsoft.Data.Sqlite" and "System.Data.SQLite" providers
    - Validates that ConnectionString is provided
    - Validates that PageSize is one of: 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536

CLASS: SqliteDatabaseOptionsBuilder
  METHODS:
    - SqliteDatabaseOptionsBuilder UseConnectionString(string connectionString)
    - SqliteDatabaseOptionsBuilder UseProvider(string providerName)
    - SqliteDatabaseOptionsBuilder UseJournalMode(string? journalMode)
    - SqliteDatabaseOptionsBuilder UsePageSize(int? pageSize)
    - SqliteDatabaseOptionsBuilder UseSynchronous(string? synchronous)

CLASS: DocumentDatabaseOptions
  PROPERTY:
    - UseJsonB : bool (default: true)
  METHODS:
    - void Validate()
  DETAILS:
    - Used by SqliteDocumentDatabase to configure document storage behavior
    - JSONB provides 20-76% faster operations

CLASS: DocumentDatabaseOptionsBuilder
  METHODS:
    - DocumentDatabaseOptionsBuilder UseJsonB(bool useJsonB=true)
    - DocumentDatabaseOptionsBuilder CacheCollection(string collectionName)
    - DocumentDatabaseOptionsBuilder CacheCollections(Func<string, bool> predicate)

================================================
NAMESPACE: Microsoft.Extensions.DependencyInjection
------------------------------------------------
CLASS (static): ServiceCollectionExtensions
  STATIC METHODS:
    - IServiceCollection AddSqliteDatabase(this IServiceCollection services, Action<SqliteDatabaseOptionsBuilder> configureOptions)
    - IServiceCollection AddDocumentDatabase(this IServiceCollection services, Action<DocumentDatabaseOptionsBuilder> configureOptions)
  DETAILS:
    Two-tier dependency injection setup:
    1. AddSqliteDatabase() registers ISqliteConnectionProvider with connection settings
    2. AddDocumentDatabase() registers IDocumentDatabase with document-specific options
    Both methods register services as singletons.
    AddSqliteDatabase must be called before AddDocumentDatabase when using DI.

================================================
SCHEMA (SQLite)
------------------------------------------------
TABLE: collections
  - id (INTEGER PRIMARY KEY AUTOINCREMENT)
  - name (TEXT NOT NULL UNIQUE)
  - created_at (TEXT NOT NULL)

TABLE: documents
  - id (INTEGER PRIMARY KEY AUTOINCREMENT)
  - collection_id (INTEGER NOT NULL, FK → collections.id ON DELETE CASCADE)
  - document_id (TEXT NOT NULL, unique within collection)
  - data (BLOB or TEXT, JSONB binary when UseJsonB=true, JSON text when UseJsonB=false)
  - created_at (TEXT NOT NULL)
  - updated_at (TEXT NOT NULL)
  - version (INTEGER DEFAULT 1)
  - UNIQUE(collection_id, document_id)

TABLE: indexes
  - id (INTEGER PRIMARY KEY AUTOINCREMENT)
  - collection_id (INTEGER NOT NULL, FK → collections.id ON DELETE CASCADE)
  - name (TEXT NOT NULL)
  - fields (TEXT NOT NULL, JSON array of field paths)
  - unique_index (INTEGER DEFAULT 0)
  - sparse (INTEGER DEFAULT 0)
  - UNIQUE(collection_id, name)

TABLE: indexed_values
  - document_id (INTEGER NOT NULL, FK → documents.id ON DELETE CASCADE)
  - index_id (INTEGER NOT NULL, FK → indexes.id ON DELETE CASCADE)
  - field_path (TEXT NOT NULL)
  - value_text (TEXT)
  - value_number (REAL)
  - value_boolean (INTEGER)
  - value_type (TEXT)

INDEXES:
  - idx_documents_collection ON documents(collection_id)
  - idx_documents_lookup ON documents(collection_id, document_id)
  - idx_indexed_values_lookup ON indexed_values(index_id, field_path, value_text)
  - idx_indexed_values_number ON indexed_values(index_id, field_path, value_number)

================================================
USAGE EXAMPLES:

BASIC SETUP (Manual instantiation):
var connectionOptions = Options.Create(new SqliteDatabaseOptions
{
    ProviderName = "Microsoft.Data.Sqlite",
    ConnectionString = "Data Source=mydb.db",
    JournalMode = "WAL",
    Synchronous = "NORMAL"
});
var connectionProvider = new SqliteConnectionProvider(connectionOptions);

var databaseOptions = Options.Create(new DocumentDatabaseOptions
{
    UseJsonB = true
});
var db = new SqliteDocumentDatabase(connectionProvider, databaseOptions);
var users = await db.GetCollectionAsync<User>("users");

BASIC SETUP (Using System.Data.SQLite provider):
var connectionOptions = Options.Create(new SqliteDatabaseOptions
{
    ProviderName = "System.Data.SQLite",
    ConnectionString = "Data Source=mydb.db",
    JournalMode = "WAL"
});
var connectionProvider = new SqliteConnectionProvider(connectionOptions);
var databaseOptions = Options.Create(new DocumentDatabaseOptions { UseJsonB = true });
var db = new SqliteDocumentDatabase(connectionProvider, databaseOptions);

NOTE: In-memory databases (Data Source=:memory:) are NOT supported due to connection-per-operation pattern.
Each new connection to :memory: creates a separate isolated database.
Always use file-based databases for both production and testing.

SETUP WITH DI (Recommended):
// Register connection provider first
services.AddSqliteDatabase(opts => opts
    .UseConnectionString("Data Source=mydb.db")
    .UseProvider("Microsoft.Data.Sqlite")
    .UseJournalMode("WAL")
    .UsePageSize(4096)
    .UseSynchronous("NORMAL"));

// Then register document database
services.AddDocumentDatabase(opts => opts
    .UseJsonB(true)
    .CacheCollection("users")
    .CacheCollections(name => name.StartsWith("hot_")));

// Then inject IDocumentDatabase in constructor
public class MyService
{
    private readonly IDocumentDatabase _db;
    public MyService(IDocumentDatabase db) => _db = db;
}

DOCUMENT CLASSES:
public class User : IDocument
{
    public DocumentId Id { get; set; }
    public string Name { get; set; }
    public int Age { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime UpdatedAt { get; set; }
}

INSERT:
var user = new User { Name = "Alice", Age = 30 };
await users.InsertOneAsync(user);
Console.WriteLine($"Inserted: {user.Id}");

FIND BY ID:
var user = await users.FindByIdAsync(new DocumentId("..."));
if (user != null) Console.WriteLine(user.Name);

FIND WITH FILTER:
var results = await users.FindAsync(u => u.Age > 25);
foreach (var u in results) Console.WriteLine(u.Name);

FIND ONE:
var user = await users.FindOneAsync(u => u.Name == "Alice");

FIND ALL:
var allUsers = await users.FindAllAsync();

FIND WITH PAGINATION:
var page = await users.FindAsync(u => u.Age > 20, skip: 10, limit: 5);

COUNT:
var count = await users.CountAsync(u => u.Age > 25);
var total = await users.CountAllAsync();

UPDATE BY ID:
var updated = new User { Name = "Bob", Age = 35 };
await users.UpdateByIdAsync(userId, updated);

UPDATE ONE:
var success = await users.UpdateOneAsync(u => u.Name == "Alice", newUser);

UPDATE MANY:
var count = await users.UpdateManyAsync(
    u => u.Age > 30,
    u => u.Age += 1);

DELETE BY ID:
await users.DeleteByIdAsync(userId);

DELETE ONE:
await users.DeleteOneAsync(u => u.Name == "Alice");

DELETE MANY:
var deleted = await users.DeleteManyAsync(u => u.Age < 18);

CHECK IF EXISTS:
bool exists = await users.AnyAsync(u => u.Name == "Alice");

INDEXING:
await users.CreateIndexAsync(u => u.Name);
await users.CreateIndexAsync(u => u.Age, unique: false);
await users.DropIndexAsync(u => u.Name);

COMPLEX QUERIES:
// AND
var results = await users.FindAsync(u => u.Age > 25 && u.Name == "Alice");

// OR
var results = await users.FindAsync(u => u.Age < 18 || u.Age > 65);

// String operations
var results = await users.FindAsync(u => u.Name.Contains("li"));
var results = await users.FindAsync(u => u.Name.StartsWith("A"));
var results = await users.FindAsync(u => u.Name.EndsWith("ice"));

// NOT
var results = await users.FindAsync(u => !(u.Age > 30));

================================================
DOCUMENT ID DETAILS:
- 12 bytes total
  - 4 bytes: Unix timestamp (seconds)
  - 5 bytes: Random value
  - 3 bytes: Counter (unique per process)
- Sortable by creation time
- Guaranteed unique within a process (static counter, thread-safe)
- Convert to/from hex string (24 chars)
- Convert to/from byte array
- Comparable and equatable

================================================
BEST PRACTICES:
- Document classes must implement IDocument interface (Id, CreatedAt, UpdatedAt properties).
- Use two-tier DI pattern: AddSqliteDatabase() then AddDocumentDatabase() for production applications.
- All queries use json_extract() with SQLite's built-in JSON support.
- JSONB storage is enabled by default for 20-76% performance improvement.
- Use collection caching for frequently accessed, read-heavy collections.
- Indexes improve query performance on frequently filtered fields.
- Use unique indexes to enforce document uniqueness on specific fields.
- DocumentId is a value type (struct) — lightweight and zero-allocation.
- JSON is stored as JSONB binary (default) or JSON text in documents table (camelCase for consistency).
- Library uses standard .NET exceptions (ArgumentException, InvalidOperationException, etc.).
- QueryTranslator automatically converts filter expressions to SQL WHERE clauses.
- Nested property filtering is supported via JSON path expressions.
- GetCollectionAsync is async - always use await when getting collections.
- Connection-per-operation: Each operation creates and disposes its own connection.
- IMPORTANT: In-memory databases (Data Source=:memory:) are NOT compatible with connection-per-operation.
- Always use file-based databases for production and testing.
- SqliteDocumentDatabase does NOT implement IDisposable (no persistent connections to dispose).
- Don't use 'using' statements with SqliteDocumentDatabase.
- Supports both Microsoft.Data.Sqlite (default) and System.Data.SQLite providers via ProviderName setting.

PERFORMANCE:
- JSONB provides 20-76% faster operations (inserts, queries, updates).
- JSONB reduces storage size by 5-10%.
- Collection caching eliminates database round-trips for cached documents.
- WAL mode (default) provides better concurrency for multi-threaded applications.
- Appropriate page size (default 4096) balances memory and performance.
- Connection-per-operation provides thread safety without connection pooling overhead.
- Each operation's connection is properly disposed, preventing connection leaks.

CONNECTION ARCHITECTURE:
- Pattern: Connection-per-operation (not connection pooling)
- Each database operation: CreateConnection() → Execute → Dispose()
- SQLite pragmas (WAL, page size, synchronous) applied per connection
- Schema initialized once via thread-safe lazy initialization
- No persistent connections maintained between operations
- IDocumentDatabase does NOT implement IDisposable (nothing to dispose)