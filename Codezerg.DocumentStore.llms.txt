LIBRARY: Codezerg.DocumentStore
LANGUAGE: C#
TARGET_FRAMEWORK: netstandard2.0
DESCRIPTION: Full reference for document-oriented data layer for SQLite — flexible, schema-less, and fully embedded.

================================================
NAMESPACE: Codezerg.DocumentStore
------------------------------------------------
INTERFACE: IDocumentDatabase : IDisposable
  PROPERTY:
    - DatabaseName : string
    - ConnectionString : string
  METHODS:
    - Task<IDocumentCollection<T>> GetCollectionAsync<T>(string name) where T : class
    - Task CreateCollectionAsync<T>(string name) where T : class
    - Task DropCollectionAsync(string name)
    - Task<List<string>> ListCollectionNamesAsync()

INTERFACE: IDocumentCollection<T> where T : class
  PROPERTY:
    - CollectionName : string
  METHODS (INSERT):
    - Task InsertOneAsync(T document)
    - Task InsertManyAsync(IEnumerable<T> documents)
  METHODS (FIND):
    - Task<T?> FindByIdAsync(DocumentId id)
    - Task<T?> FindOneAsync(Expression<Func<T, bool>> filter)
    - Task<List<T>> FindAsync(Expression<Func<T, bool>> filter)
    - Task<List<T>> FindAllAsync()
    - Task<List<T>> FindAsync(Expression<Func<T, bool>> filter, int skip, int limit)
  METHODS (COUNT):
    - Task<long> CountAsync(Expression<Func<T, bool>> filter)
    - Task<long> CountAllAsync()
  METHODS (UPDATE):
    - Task<bool> UpdateByIdAsync(DocumentId id, T document)
    - Task<bool> UpdateOneAsync(Expression<Func<T, bool>> filter, T document)
    - Task<long> UpdateManyAsync(Expression<Func<T, bool>> filter, Action<T> updateAction)
  METHODS (DELETE):
    - Task<bool> DeleteByIdAsync(DocumentId id)
    - Task<bool> DeleteOneAsync(Expression<Func<T, bool>> filter)
    - Task<long> DeleteManyAsync(Expression<Func<T, bool>> filter)
  METHODS (QUERY):
    - Task<bool> AnyAsync(Expression<Func<T, bool>> filter)
  METHODS (INDEXING):
    - Task CreateIndexAsync<TField>(Expression<Func<T, TField>> fieldExpression, bool unique=false)
    - Task DropIndexAsync<TField>(Expression<Func<T, TField>> fieldExpression)


CLASS: DocumentId : IEquatable<DocumentId>, IComparable<DocumentId>
  CTORS:
    - DocumentId()
    - DocumentId(byte[] value)
    - DocumentId(string hexString)
  STATIC PROPERTY:
    - Empty : DocumentId
  PROPERTY:
    - Timestamp : DateTime
  STATIC METHODS:
    - DocumentId NewId()
    - DocumentId Parse(string hexString)
    - bool TryParse(string? hexString, out DocumentId id)
  METHODS:
    - override string ToString()
    - byte[] ToByteArray()
    - override bool Equals(object? obj)
    - bool Equals(DocumentId other)
    - override int GetHashCode()
    - int CompareTo(DocumentId other)
  OPERATORS:
    - == (left, right)
    - != (left, right)
    - < (left, right)
    - > (left, right)
    - <= (left, right)
    - >= (left, right)

CLASS: SqliteDocumentDatabase : IDocumentDatabase
  CTORS:
    - SqliteDocumentDatabase(string connectionString, ILogger<SqliteDocumentDatabase>? logger=null, bool useJsonB=true)
    - SqliteDocumentDatabase(IOptions<DocumentDatabaseOptions> options, ILogger<SqliteDocumentDatabase>? logger=null)
  PROPERTY (impl):
    - DatabaseName : string
    - ConnectionString : string
    - UseJsonB : bool
  METHODS (impl):
    - Task<IDocumentCollection<T>> GetCollectionAsync<T>(string name) where T : class
    - Task CreateCollectionAsync<T>(string name) where T : class
    - Task DropCollectionAsync(string name)
    - Task<List<string>> ListCollectionNamesAsync()
    - void Dispose()
  INTERNAL METHODS:
    - SqliteConnection CreateConnection() (creates new connection per operation)
    - bool IsJsonBEnabled()
  CONNECTION MANAGEMENT:
    - Uses connection-per-operation pattern
    - Each database operation creates and disposes its own connection
    - No persistent connections maintained
    - SQLite pragmas applied to each new connection
    - Thread-safe schema initialization
    - IMPORTANT: In-memory databases (:memory:) are NOT supported

CLASS (internal): SqliteDocumentCollection<T> : IDocumentCollection<T> where T : class
  CTORS:
    - SqliteDocumentCollection(SqliteDocumentDatabase database, string collectionName, ILogger logger, bool useJsonB)
  PROPERTY (impl):
    - CollectionName : string
  METHODS (impl):
    - Task InsertOneAsync(T document)
    - Task InsertManyAsync(IEnumerable<T> documents)
    - Task<T?> FindByIdAsync(DocumentId id)
    - Task<T?> FindOneAsync(Expression<Func<T, bool>> filter)
    - Task<List<T>> FindAsync(Expression<Func<T, bool>> filter)
    - Task<List<T>> FindAllAsync()
    - Task<List<T>> FindAsync(Expression<Func<T, bool>> filter, int skip, int limit)
    - Task<long> CountAsync(Expression<Func<T, bool>> filter)
    - Task<long> CountAllAsync()
    - Task<bool> UpdateByIdAsync(DocumentId id, T document)
    - Task<bool> UpdateOneAsync(Expression<Func<T, bool>> filter, T document)
    - Task<long> UpdateManyAsync(Expression<Func<T, bool>> filter, Action<T> updateAction)
    - Task<bool> DeleteByIdAsync(DocumentId id)
    - Task<bool> DeleteOneAsync(Expression<Func<T, bool>> filter)
    - Task<long> DeleteManyAsync(Expression<Func<T, bool>> filter)
    - Task<bool> AnyAsync(Expression<Func<T, bool>> filter)
    - Task CreateIndexAsync<TField>(Expression<Func<T, TField>> fieldExpression, bool unique=false)
    - Task DropIndexAsync<TField>(Expression<Func<T, TField>> fieldExpression)

CLASS (internal): CachedDocumentCollection<T> : IDocumentCollection<T> where T : class
  DETAILS:
    In-memory caching wrapper for IDocumentCollection<T>.
    Caches documents by DocumentId in a ConcurrentDictionary.
    Automatically invalidates cache on writes.
    Provides transparent caching without changing the API surface.

CLASS (internal static): QueryTranslator
  STATIC METHODS:
    - (string WhereClause, List<object?> Parameters) Translate<T>(Expression<Func<T, bool>> expression)
  DETAILS:
    Translates LINQ expressions to SQLite WHERE clauses with JSON operations.
    Supports: ==, !=, >, <, >=, <=, &&, ||, !
    Supports: String.Contains, String.StartsWith, String.EndsWith
    Uses json_extract(data, '$.fieldName') for field access.
    Converts PascalCase properties to camelCase in JSON paths.

CLASS (internal static): Compat
  DETAILS:
    Compatibility helpers for netstandard2.0
  STATIC METHODS:
    - int GetRandomInt32(int minValue, int maxValue)
    - void FillRandom(byte[] data, int offset, int count)
    - byte[] FromHexString(string hex)
    - string ToHexString(byte[] bytes)
    - int GetHashCodeForBytes(byte[] bytes)

================================================
NAMESPACE: Codezerg.DocumentStore.Configuration
------------------------------------------------
CLASS: DocumentDatabaseOptions
  PROPERTY:
    - ConnectionString : string?
    - UseJsonB : bool (default: true)
    - JournalMode : string? (default: "WAL")
    - PageSize : int? (default: 4096)
    - Synchronous : string? (default: "NORMAL")
    - CachedCollectionPredicates : List<Func<string, bool>> (internal)
  METHODS:
    - void Validate() (internal)

CLASS: DocumentDatabaseOptionsBuilder
  METHODS:
    - DocumentDatabaseOptionsBuilder UseConnectionString(string connectionString)
    - DocumentDatabaseOptionsBuilder UseJsonB(bool useJsonB=true)
    - DocumentDatabaseOptionsBuilder UseJournalMode(string? journalMode)
    - DocumentDatabaseOptionsBuilder UsePageSize(int? pageSize)
    - DocumentDatabaseOptionsBuilder UseSynchronous(string? synchronous)
    - DocumentDatabaseOptionsBuilder CacheCollection(string collectionName)
    - DocumentDatabaseOptionsBuilder CacheCollections(Func<string, bool> predicate)
    - DocumentDatabaseOptions Build() (internal)

================================================
NAMESPACE: Codezerg.DocumentStore.Exceptions
------------------------------------------------
CLASS: DocumentNotFoundException : Exception
  PROPERTY:
    - DocumentId : DocumentId?
    - CollectionName : string?
  CTORS:
    - DocumentNotFoundException()
    - DocumentNotFoundException(string message)
    - DocumentNotFoundException(string message, Exception innerException)
    - DocumentNotFoundException(DocumentId documentId, string collectionName)

CLASS: DuplicateKeyException : Exception
  PROPERTY:
    - KeyValue : object?
    - CollectionName : string?
  CTORS:
    - DuplicateKeyException()
    - DuplicateKeyException(string message)
    - DuplicateKeyException(string message, Exception innerException)
    - DuplicateKeyException(object keyValue, string collectionName)

CLASS: InvalidQueryException : Exception
  PROPERTY:
    - QueryExpression : string?
  CTORS:
    - InvalidQueryException()
    - InvalidQueryException(string message)
    - InvalidQueryException(string message, Exception innerException)
    - InvalidQueryException(string message, string queryExpression)

================================================
NAMESPACE: Codezerg.DocumentStore.Serialization
------------------------------------------------
CLASS (internal): DocumentIdJsonConverter : JsonConverter<DocumentId>
  METHODS:
    - DocumentId Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    - void Write(Utf8JsonWriter writer, DocumentId value, JsonSerializerOptions options)

CLASS (internal static): DocumentSerializer
  STATIC PROPERTY:
    - DefaultOptions : JsonSerializerOptions
  DETAILS:
    PropertyNamingPolicy: CamelCase
    PropertyNameCaseInsensitive: true
    DefaultIgnoreCondition: WhenWritingNull
    WriteIndented: false
    Converters: DocumentIdJsonConverter, JsonStringEnumConverter
  STATIC METHODS:
    - string Serialize<T>(T document, JsonSerializerOptions? options=null)
    - T? Deserialize<T>(string json, JsonSerializerOptions? options=null)
    - T DeserializeNonNull<T>(string json, JsonSerializerOptions? options=null)

================================================
SCHEMA (SQLite)
------------------------------------------------
TABLE: collections
  - id (INTEGER PRIMARY KEY AUTOINCREMENT)
  - name (TEXT NOT NULL UNIQUE)
  - created_at (TEXT NOT NULL)

TABLE: documents
  - id (INTEGER PRIMARY KEY AUTOINCREMENT)
  - collection_id (INTEGER NOT NULL, FK → collections.id ON DELETE CASCADE)
  - document_id (TEXT NOT NULL, unique within collection)
  - data (BLOB or TEXT, JSONB binary when UseJsonB=true, JSON text when UseJsonB=false)
  - created_at (TEXT NOT NULL)
  - updated_at (TEXT NOT NULL)
  - version (INTEGER DEFAULT 1)
  - UNIQUE(collection_id, document_id)

TABLE: indexes
  - id (INTEGER PRIMARY KEY AUTOINCREMENT)
  - collection_id (INTEGER NOT NULL, FK → collections.id ON DELETE CASCADE)
  - name (TEXT NOT NULL)
  - fields (TEXT NOT NULL, JSON array of field paths)
  - unique_index (INTEGER DEFAULT 0)
  - sparse (INTEGER DEFAULT 0)
  - UNIQUE(collection_id, name)

TABLE: indexed_values
  - document_id (INTEGER NOT NULL, FK → documents.id ON DELETE CASCADE)
  - index_id (INTEGER NOT NULL, FK → indexes.id ON DELETE CASCADE)
  - field_path (TEXT NOT NULL)
  - value_text (TEXT)
  - value_number (REAL)
  - value_boolean (INTEGER)
  - value_type (TEXT)

INDEXES:
  - idx_documents_collection ON documents(collection_id)
  - idx_documents_lookup ON documents(collection_id, document_id)
  - idx_indexed_values_lookup ON indexed_values(index_id, field_path, value_text)
  - idx_indexed_values_number ON indexed_values(index_id, field_path, value_number)

================================================
USAGE EXAMPLES:

BASIC SETUP:
var db = new SqliteDocumentDatabase("Data Source=mydb.db");
var users = await db.GetCollectionAsync<User>("users");

BASIC SETUP (JSONB disabled):
var db = new SqliteDocumentDatabase("Data Source=mydb.db", useJsonB: false);
var users = await db.GetCollectionAsync<User>("users");

NOTE: In-memory databases (Data Source=:memory:) are NOT supported due to connection-per-operation pattern.
Each new connection to :memory: creates a separate isolated database.
Always use file-based databases for both production and testing.

SETUP WITH DI:
services.AddDocumentDatabase(opts =>
    opts.UseConnectionString("Data Source=mydb.db")
        .UseJsonB(true)
        .UseJournalMode("WAL")
        .UsePageSize(4096)
        .UseSynchronous("NORMAL")
        .CacheCollection("users")
        .CacheCollections(name => name.StartsWith("hot_")));
// Then inject IDocumentDatabase in constructor

DOCUMENT CLASSES:
public class User
{
    public DocumentId Id { get; set; }
    public string Name { get; set; }
    public int Age { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime UpdatedAt { get; set; }
}

INSERT:
var user = new User { Name = "Alice", Age = 30 };
await users.InsertOneAsync(user);
Console.WriteLine($"Inserted: {user.Id}");

FIND BY ID:
var user = await users.FindByIdAsync(new DocumentId("..."));
if (user != null) Console.WriteLine(user.Name);

FIND WITH FILTER:
var results = await users.FindAsync(u => u.Age > 25);
foreach (var u in results) Console.WriteLine(u.Name);

FIND ONE:
var user = await users.FindOneAsync(u => u.Name == "Alice");

FIND ALL:
var allUsers = await users.FindAllAsync();

FIND WITH PAGINATION:
var page = await users.FindAsync(u => u.Age > 20, skip: 10, limit: 5);

COUNT:
var count = await users.CountAsync(u => u.Age > 25);
var total = await users.CountAllAsync();

UPDATE BY ID:
var updated = new User { Name = "Bob", Age = 35 };
await users.UpdateByIdAsync(userId, updated);

UPDATE ONE:
var success = await users.UpdateOneAsync(u => u.Name == "Alice", newUser);

UPDATE MANY:
var count = await users.UpdateManyAsync(
    u => u.Age > 30,
    u => u.Age += 1);

DELETE BY ID:
await users.DeleteByIdAsync(userId);

DELETE ONE:
await users.DeleteOneAsync(u => u.Name == "Alice");

DELETE MANY:
var deleted = await users.DeleteManyAsync(u => u.Age < 18);

CHECK IF EXISTS:
bool exists = await users.AnyAsync(u => u.Name == "Alice");

INDEXING:
await users.CreateIndexAsync(u => u.Name);
await users.CreateIndexAsync(u => u.Age, unique: false);
await users.DropIndexAsync(u => u.Name);

COMPLEX QUERIES:
// AND
var results = await users.FindAsync(u => u.Age > 25 && u.Name == "Alice");

// OR
var results = await users.FindAsync(u => u.Age < 18 || u.Age > 65);

// String operations
var results = await users.FindAsync(u => u.Name.Contains("li"));
var results = await users.FindAsync(u => u.Name.StartsWith("A"));
var results = await users.FindAsync(u => u.Name.EndsWith("ice"));

// NOT
var results = await users.FindAsync(u => !(u.Age > 30));

================================================
DOCUMENT ID DETAILS:
- 12 bytes total
  - 4 bytes: Unix timestamp (seconds)
  - 5 bytes: Random value
  - 3 bytes: Counter (unique per process)
- Sortable by creation time
- Guaranteed unique within a process (static counter, thread-safe)
- Convert to/from hex string (24 chars)
- Convert to/from byte array
- Comparable and equatable

================================================
BEST PRACTICES:
- Document classes should have Id, CreatedAt, UpdatedAt properties for automatic management.
- Use DI pattern with AddDocumentDatabase() for production applications.
- All queries use json_extract() with SQLite's built-in JSON support.
- JSONB storage is enabled by default for 20-76% performance improvement.
- Use collection caching for frequently accessed, read-heavy collections.
- Indexes improve query performance on frequently filtered fields.
- Use unique indexes to enforce document uniqueness on specific fields.
- DocumentId is a value type (struct) — lightweight and zero-allocation.
- JSON is stored as JSONB binary (default) or JSON text in documents table (camelCase for consistency).
- Exceptions: DocumentNotFoundException, DuplicateKeyException, InvalidQueryException.
- QueryTranslator automatically converts filter expressions to SQL WHERE clauses.
- Nested property filtering is supported via JSON path expressions.
- GetCollectionAsync is now async - always use await when getting collections.
- Connection-per-operation: Each operation creates and disposes its own connection.
- IMPORTANT: In-memory databases (Data Source=:memory:) are NOT compatible with connection-per-operation.
- Always use file-based databases for production and testing.
- Dispose() on SqliteDocumentDatabase does not close a persistent connection (no persistent connection exists).

PERFORMANCE:
- JSONB provides 20-76% faster operations (inserts, queries, updates).
- JSONB reduces storage size by 5-10%.
- Collection caching eliminates database round-trips for cached documents.
- WAL mode (default) provides better concurrency for multi-threaded applications.
- Appropriate page size (default 4096) balances memory and performance.
- Connection-per-operation provides thread safety without connection pooling overhead.
- Each operation's connection is properly disposed, preventing connection leaks.

CONNECTION ARCHITECTURE:
- Pattern: Connection-per-operation (not connection pooling)
- Each database operation: CreateConnection() → Execute → Dispose()
- SQLite pragmas (WAL, page size, synchronous) applied per connection
- Schema initialized once via thread-safe lazy initialization
- No persistent connections maintained between operations
- Disposal cleans up resources but doesn't close a persistent connection